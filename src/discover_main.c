/*
 * discover_main.c - XVC Discovery Tool Main Entry
 * XVC Server for Digilent HS2
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include "device_manager.h"
#include "config.h"
#include "logging.h"

#define VERSION "1.0.0"

/* Output format */
typedef enum {
    FORMAT_INI = 0,
    FORMAT_JSON,
    FORMAT_YAML
} output_format_t;

/* Command line options */
static struct {
    char output_file[256];
    output_format_t format;
    int base_port;
    int verbose;
    int quiet;
} opts = {
    .output_file = "",
    .format = FORMAT_INI,
    .base_port = DEFAULT_BASE_PORT,
    .verbose = 0,
    .quiet = 0
};

static void print_usage(const char *prog)
{
    printf("Usage: %s [OPTIONS]\n\n", prog);
    printf("Scan for Digilent HS2 devices and generate configuration.\n\n");
    printf("Options:\n");
    printf("  -o, --output FILE      Output configuration file (default: stdout)\n");
    printf("  -f, --format FORMAT    Output format: ini, json, yaml (default: ini)\n");
    printf("  -b, --base-port PORT   Base port for instance numbering (default: %d)\n", DEFAULT_BASE_PORT);
    printf("  -v, --verbose          Enable verbose output\n");
    printf("  -q, --quiet            Suppress normal output\n");
    printf("  -h, --help             Display this help message\n");
    printf("  -V, --version          Display version information\n");
}

static void print_version(void)
{
    printf("xvc-discover version %s\n", VERSION);
    printf("Digilent HS2 device discovery tool for XVC Server\n");
}

static int output_json(const device_manager_t *mgr, FILE *fp)
{
    fprintf(fp, "{\n");
    fprintf(fp, "  \"version\": \"%s\",\n", VERSION);
    fprintf(fp, "  \"base_port\": %d,\n", opts.base_port);
    fprintf(fp, "  \"devices\": [\n");
    
    for (int i = 0; i < mgr->device_count; i++) {
        const hs2_device_t *dev = &mgr->devices[i];
        fprintf(fp, "    {\n");
        fprintf(fp, "      \"instance_id\": %d,\n", i + 1);
        fprintf(fp, "      \"port\": %d,\n", opts.base_port + i);
        fprintf(fp, "      \"manufacturer\": \"%s\",\n", dev->manufacturer);
        fprintf(fp, "      \"product\": \"%s\",\n", dev->product);
        fprintf(fp, "      \"serial\": \"%s\",\n", dev->serial);
        fprintf(fp, "      \"bus_location\": \"%s\"\n", dev->bus_location);
        fprintf(fp, "    }%s\n", (i < mgr->device_count - 1) ? "," : "");
    }
    
    fprintf(fp, "  ]\n");
    fprintf(fp, "}\n");
    
    return 0;
}

static int output_yaml(const device_manager_t *mgr, FILE *fp)
{
    fprintf(fp, "# XVC Server Device Configuration\n");
    fprintf(fp, "version: \"%s\"\n", VERSION);
    fprintf(fp, "base_port: %d\n\n", opts.base_port);
    fprintf(fp, "devices:\n");
    
    for (int i = 0; i < mgr->device_count; i++) {
        const hs2_device_t *dev = &mgr->devices[i];
        fprintf(fp, "  - instance_id: %d\n", i + 1);
        fprintf(fp, "    port: %d\n", opts.base_port + i);
        fprintf(fp, "    manufacturer: \"%s\"\n", dev->manufacturer);
        fprintf(fp, "    product: \"%s\"\n", dev->product);
        fprintf(fp, "    serial: \"%s\"\n", dev->serial);
        fprintf(fp, "    bus_location: \"%s\"\n", dev->bus_location);
        if (i < mgr->device_count - 1) fprintf(fp, "\n");
    }
    
    return 0;
}

static int output_ini(const device_manager_t *mgr, FILE *fp)
{
    xvc_global_config_t config;
    device_manager_generate_config(mgr, &config, opts.base_port);
    
    fprintf(fp, "# XVC Server Configuration\n");
    fprintf(fp, "# Generated by xvc-discover %s\n", VERSION);
    fprintf(fp, "# Edit this file to customize settings\n\n");
    
    fprintf(fp, "[instance_management]\n");
    fprintf(fp, "enabled = true\n");
    fprintf(fp, "base_port = %d\n", opts.base_port);
    fprintf(fp, "max_instances = %d\n\n", MAX_INSTANCES);
    
    fprintf(fp, "[instance_mappings]\n");
    fprintf(fp, "# Format: instance_id = device_id\n");
    fprintf(fp, "# device_id: SN:serial, BUS:bus-dev, CUSTOM:name, or auto\n");
    
    for (int i = 0; i < config.instance_count; i++) {
        const xvc_instance_config_t *inst = &config.instances[i];
        const hs2_device_t *dev = &mgr->devices[i];
        
        char id_str[128];
        config_format_device_id(&inst->device_id, id_str, sizeof(id_str));
        
        fprintf(fp, "%d = %-20s  # %s: %s\n", 
                inst->instance_id, id_str, 
                dev->product, dev->manufacturer);
    }
    fprintf(fp, "\n");
    
    fprintf(fp, "[instance_settings]\n");
    fprintf(fp, "# Per-instance settings (format: id:setting = value)\n");
    for (int i = 0; i < config.instance_count; i++) {
        fprintf(fp, "%d:frequency = %u\n", i + 1, DEFAULT_FREQUENCY);
        fprintf(fp, "%d:xvc_buffer_size = %d\n", i + 1, 131088);
    }
    fprintf(fp, "\n");
    
    fprintf(fp, "[instance_aliases]\n");
    fprintf(fp, "# Human-readable names for instances\n");
    for (int i = 0; i < config.instance_count; i++) {
        fprintf(fp, "%d = %s\n", i + 1, config.instances[i].alias);
    }
    fprintf(fp, "\n");
    
    return 0;
}

int main(int argc, char *argv[])
{
    static struct option long_options[] = {
        {"output",    required_argument, 0, 'o'},
        {"format",    required_argument, 0, 'f'},
        {"base-port", required_argument, 0, 'b'},
        {"verbose",   no_argument,       0, 'v'},
        {"quiet",     no_argument,       0, 'q'},
        {"help",      no_argument,       0, 'h'},
        {"version",   no_argument,       0, 'V'},
        {0, 0, 0, 0}
    };
    
    int opt;
    while ((opt = getopt_long(argc, argv, "o:f:b:vqhV", long_options, NULL)) != -1) {
        switch (opt) {
            case 'o':
                strncpy(opts.output_file, optarg, sizeof(opts.output_file) - 1);
                break;
            case 'f':
                if (strcmp(optarg, "json") == 0) {
                    opts.format = FORMAT_JSON;
                } else if (strcmp(optarg, "yaml") == 0) {
                    opts.format = FORMAT_YAML;
                } else {
                    opts.format = FORMAT_INI;
                }
                break;
            case 'b':
                opts.base_port = atoi(optarg);
                break;
            case 'v':
                opts.verbose++;
                break;
            case 'q':
                opts.quiet = 1;
                break;
            case 'h':
                print_usage(argv[0]);
                return 0;
            case 'V':
                print_version();
                return 0;
            default:
                print_usage(argv[0]);
                return 1;
        }
    }
    
    /* Initialize logging */
    log_config_t log_cfg = {
        .level = opts.verbose ? XVC_LOG_DEBUG : (opts.quiet ? XVC_LOG_ERROR : XVC_LOG_INFO),
        .targets = LOG_TARGET_STDERR,
        .include_timestamp = false,
        .include_level = true,
        .include_source = opts.verbose > 1
    };
    log_init(&log_cfg);
    
    /* Initialize device manager */
    device_manager_t mgr;
    if (device_manager_init(&mgr) < 0) {
        fprintf(stderr, "Failed to initialize device manager\n");
        return 1;
    }
    
    /* Scan for devices */
    int count = device_manager_scan(&mgr);
    if (count < 0) {
        fprintf(stderr, "Device scan failed\n");
        device_manager_shutdown(&mgr);
        return 1;
    }
    
    if (count == 0) {
        if (!opts.quiet) {
            printf("No Digilent HS2 devices detected.\n");
            printf("Please check:\n");
            printf("  - USB connections\n");
            printf("  - USB permissions (try running with sudo)\n");
            printf("  - Device drivers (libftdi1)\n");
        }
        device_manager_shutdown(&mgr);
        return 0;
    }
    
    /* Print device list */
    if (!opts.quiet && !opts.output_file[0]) {
        device_manager_print(&mgr, opts.verbose);
    }
    
    /* Output configuration */
    FILE *fp = stdout;
    if (opts.output_file[0]) {
        fp = fopen(opts.output_file, "w");
        if (!fp) {
            fprintf(stderr, "Cannot open output file: %s\n", opts.output_file);
            device_manager_shutdown(&mgr);
            return 1;
        }
    }
    
    int ret = 0;
    switch (opts.format) {
        case FORMAT_JSON:
            ret = output_json(&mgr, fp);
            break;
        case FORMAT_YAML:
            ret = output_yaml(&mgr, fp);
            break;
        default:
            ret = output_ini(&mgr, fp);
            break;
    }
    
    if (opts.output_file[0]) {
        fclose(fp);
        if (!opts.quiet) {
            printf("\nConfiguration written to: %s\n", opts.output_file);
            printf("Edit the configuration file to customize settings, then run:\n");
            printf("  sudo xvc-server %s\n", opts.output_file);
        }
    }
    
    device_manager_shutdown(&mgr);
    log_shutdown();
    
    return ret;
}
